<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>

    <h1>리액트를 위한 JavaScript 문법 정리</h1>

    <div>
        <h2>1.화살표 함수 (Arrow Function)</h2>
        <p>리액트에서 가장 많이 사용하는 함수 선언 방식</p>

        <pre>
            <code>
                //기존 함수
                function sayHello(name){
                    return "안녕하세요 " + name;
                }

                //화살표 함수
                const sayHello = (name) => {
                    return "안녕하세요 " + name;
                }

                //더 간단하게 (한줄처리)
                const sayHello = (name) => "안녕하세요 " + name;

                //매개변수가 없는 경우
                const sayHello = () => "안녕하세요";

                //일반 함수와 화살표 함수 차이점 : this 바인딩 차이점
                //일반 함수 : 호출하는 객체에 따라 this가 결정된다.
                //화살표 함수 : 선언된 위치의 this를 그대로 사용한다. 

                //리액트 컴포넌트에서 사용되는 형태
                const Button = () => {
                    return &lt;button&gt;클릭&lt;/button&gt;
                }


            </code>
        </pre>
    </div>

    <script>
        const user = {
            name : "kim",
            sayHi : function(){
                console.log(this.name);
            }
        }

        user.sayHi();

        const user2 = {
            name : "park",
            sayHi : function(){
                setTimeout(function(){
                    console.log(this); // 윈도우 객체
                    console.log(this.name);
                },1000); 
            }
        }

        user2.sayHi();

        //화살표 함수는 바깥쪽 this를 그대로 이용한다. (상위 this 유지)
        const user3 = {
            name:"leeyein",
            sayHi: function(){
                setTimeout(() => {
                    console.log(this);
                    console.log(this.name);
                }, 1000); 
            }
        };

        user3.sayHi(); 
    </script>

    <div>
        <h2>2. 구조 분해 할당</h2>
        <p>객체나 배열에서 값을 쉽게 꺼내는 방법</p>
        <pre>
            <code>
                객체 구조 분해
                const user = {name : '김철수', age:20, city:'서울'};
                const {name,age} = user;
                console.log(name);
                console.log(age);

                배열 구조 분해
                const colors = ['빨강','노랑','파랑'];
                const [red,yellow,blue] = colors;
                console.log(red);
                console.log(yellow);
                console.log(blue); 
            </code>
        </pre>

    </div>

    <script>
        const user4 = {name : '김철수', age:20, city:'서울'};
        const {name,age,city} = user4;
        console.log('--user4--');
        console.log(name);
        console.log(age);
        console.log(city);

        const colors = ['빨강','노랑','파랑'];
        const [red,yellow,blue] = colors;
        console.log(red);
        console.log(yellow);
        console.log(blue); 
    </script>

    <div>
        <h2>3.스프레드 연산자(...)</h2>
        <p>배열이나 객체를 펼치거나 복사할 때 사용</p>
        <pre>
            <code>
                배열 복사 및 합치기
                const fruits = ['사과','딸기'];
                const moreFruits = [...fruits,'수박'];

                객체 복사 및 수정
                const person = {name:'김철수', age:20};
                const updatePerson = {...person,age:30}; 
            </code>
        </pre>
    </div>

    <script>
        //배열 복사 및 합치기
        const fruits = ['사과','딸기'];
        const moreFruits = [...fruits,'수박'];

        console.log(fruits);
        console.log(moreFruits); 

        //객체 복사 및 수정
        const person = {name:'김철수', age:20};
        const updatePerson = {...person,age:30};

        console.log(person);
        console.log(updatePerson); 
    </script>

    <div>
        <h2>4.템플릿 리터럴</h2>
        <p>문자열 안에 변수를 쉽게 넣는 방법</p>
        <pre>
            <code>
                const name = "김철수";
                const age = 20;

                //기존 방식
                const str = "안녕하세요 " + name + "님 당신의 나이는 " + age + "살 이군요.";
                
                //템플릿 리터럴(백틱 ` 사용)
                const str2 = "안녕하세요 ${name}님 당신의 나이는 ${age}살 이군요";

                //여러줄 문자열도 가능
                const multiLine = `
                    첫번째 줄
                    두번째
                    ${name}님의 정보`;
            </code>
        </pre>
    </div>
    
    <script>
        const name1 = "김철수";
        const age1 = 20;

        //기존방식
        const str = "안녕하세요 " + name1 + "님 당신의 나이는 " + age1 +"살 입니까?";

        //템플릿 리터럴(백틱 ` 사용)
        const str2 = `안녕하세요 ${name1}님 당신의 나이는 ${age1}살 이군요`;

        //여러줄 문자열도 가능
        const multiLine = `
            첫번째 줄 
            두번째
            ${name1}님의 정보`;
        
        console.log(str);
        console.log(str2);
        console.log(multiLine);    
    </script>

    <div>
        <h2>5.배열 메소드 (map,filter,find)</h2>
        <p>리액트에서 리스트를 랜더링 할 때 사용되는 구문</p>
        <pre>
            <code>
                const users = {
                    {id:1,name:'김철수',age:20},
                    {id:2,name:'박유저',age:30},
                    {id:3,name:'이예인',age:25}
                };

                //map : 배열의 각 요소를 반환
                const names = users.map(user => user.name);

                //filter : 배열에서 조건에 맞는 요소만 선택
                const adults = users.filter(user => user.age>20);

                //find : 조건에 맞는 첫번째 요소 찾기
                const foundUser = users.find(user=>user.name==='박유저');

            </code>
        </pre>
    </div>

    <script>
        const users = [
            {id:1,name:'김철수',age:20},
            {id:2,name:'박유저',age:30},
            {id:3,name:'이예인',age:25}
        ];

        //map : 배열의 각 요소를 반환
        const names = users.map(user => user.name+'입니다');

        console.log(names);
        console.log(users);

        //filter : 배열에서 조건에 맞는 요소만 선택
        const adults = users.filter(user => user.age>20);

        console.log(adults);

        //find : 조건에 맞는 첫번째 요소 찾기
        const foundUser = users.find(user=>user.name==='박유저');

        console.log(foundUser); 
    </script>

    <div>
        <h2>6.삼항 연산자</h2>
        <p>조건에 따라 다른 값을 반환할때 사용</p>
        <pre>
            <code>
                const age = 20;

                //기본형태 : 조건 ? 참일때 : 거짓일때;
                const message = age > 19 ? '성인입니다' : '미성년자입니다';
            </code>
        </pre>
    </div>

    <div>
        <h2>7.논리연산자 (&&,||)</h2>
        <p>조건부 렌더링에서 자주 사용된다.</p>

        <pre>
            <code>
                && : 앞이 true면 뒤를 실행
                const hasData = true;
                const result = hasData && '데이터가 있습니다.';

                || : 앞이 false면 뒤를 실행
                const userName = null;
                const displayName = userName || '게스트';

                리액트에서 조건부 렌더링
                const Notification = ({count} => {
                    return {
                        &lt;div&gt;
                            알림
                            {count > 0 && &lt;span&gt; ({count}) &lt;/span&gt;}
                        &lt;/div&gt;    
                    }
                })

                로딩 상태 처리
                const UserProfile = ({user, isLoading}) => {
                    return (
                        &lt;div&gt;
                            {isLoading && &lt;p&gt; 로딩중.. &lt;/p&gt;}
                            {user && &lt;h1&gt; {user.name}님 환영합니다 &lt;/h1&gt;}
                        &lt;/div&gt;     
                    )
                }
            </code>
        </pre>
    </div>

    <script>
        //&& : 앞이 true면 뒤를 실행
        const hasData = true;
        const result = hasData && '데이터가 있습니다.';

        console.log(result);

        //|| : 앞이 false면 뒤를 실행
        const userName = null;
        const displayName = userName || '게스트';

        console.log(displayName); 
    </script>

    <div>
        <h2>8. 옵셔널 체이닝(?.)</h2>
        <p>객체의 속성에 안전하게 접근할 때 사용한다.</p>
        <pre>
            <div>
                const user = {
                    name : '박유저',
                    address : {
                        city : '서울',
                        street : '영등포'
                    }
                };

                //기존 방식
                const street = user.address.street;
                
                //옵셔널 체이닝 방식
                const street = user.address?.street;
                const phone = user.contact?.phone;

                //배열에서 사용
                const firstFriend = user.friends?.[0];

                //함수 호출에서 사용
                user.sayHello?.(); // sayHello만 있으면 호출

                //리액트에서 API데이터를 불러와 사용할때 유리하다.
                const UserProfile = ({userData}) => {
                    return (
                        &lt;div &gt;
                                &lt;h1&gt;{userData?.name || 이름없음}&lt;/h1&gt;
                                &lt;h1&gt;{userData?.address?.street}&lt;/h1&gt;
                        &lt;/div&gt;        

                    )
                }

                
            </div>
        </pre>
    </div>

    <script>
        const user10={
            name : '박유저',
            address : {
                city : '서울',
                street : '영등포'
            }
        };
        //기존 방식
        const street1 = user10.address.street;

        //옵셔널 체이닝 방식
        const street2 = user10.address?.street;
        const phone = user10.contact?.phone;

        //배열에서 사용
        const firstFriend = user10.friends?.[0];

        //함수 호출에서 사용
        user10.sayHello?.(); // sayHello만 있으면 호출

        console.log(street1);
        console.log(street2);
        console.log(phone);
        console.log(firstFriend); 
    </script>


</body>
</html>